#!/usr/bin/python

""" 
dimsbuild

DimsBuild wrapper
"""

import imp
import os
import sys

from os.path import join, exists, isdir
from optparse import OptionParser, SUPPRESS_HELP

from dims import configlib
from dims import listfmt

from dims.CleanHelpFormatter import CleanHelpFormatter, OptionGroupId

def main():
  parser = OptionParser("usage: %prog [OPTIONS]", formatter=CleanHelpFormatter())
  parser.add_option('-c', '--config',
                    dest='userconfig',
                    help="specify the location of the distro.conf to use")
  parser.add_option('-v', '--verbose',
                    default=False,
                    action='store_true',
                    help="enable verbose output (deprecated)")
  parser.add_option('-l', '--log-level',
                    dest='logthresh',
                    default=3,
                    help="specify the level of verbosity of the output log")
  parser.add_option('-e', '--errlog-level',
                    dest='errthresh',
                    default=1,
                    help="specify the level of verbosity of the error log")
  parser.add_option('--no-plugins',
                    default=True,
                    action='store_false',
                    dest='plugins',
                    help="disable plugins")
  parser.add_option('--conf-path', # TODO rename, confusing wrt -c, --config
                    default='/etc/dimsbuild/',
                    dest='mainconfigpath',
                    help="path to dimsbuild.conf")
  parser.add_option('--lib-path', # TODO rename in concurrence with --conf-path
                    dest='libpath',
                    help="path to dimsbuild library files")
  parser.add_option('--share-path',
                    dest='sharepath',
                    help="path to dimsbuild shared files")
  parser.add_option('--clear-cache',
                    dest='clear_cache',
                    action='store_true',
                    default=False,
                    help="clear cache of downloaded files before executing")
  parser.add_option('--clean',
                    action='callback',
                    dest='clean_events',
                    metavar='EVENT1 [EVENT2 ...]',
                    default=[],
                    callback=append_events_callback,
                    help="specify a list of events that are forced to execute, " + \
                         "even if normal program execution would ordinarily skip " + \
                         "them.  See above for the list of accepted events")
  parser.add_option('--skip',
                    action='callback',
                    dest='skip_events',
                    metavar='EVENT1 [EVENT2 ...]',
                    default=[],
                    callback=append_events_callback,
                    help="specify a list of events that are prevented from " + \
                         "being executed, even if normal program execution " + \
                         "would ordinarily run them.  See above for the list " + \
                         "of accepted events")

  
  buildgroup = OptionGroupId(parser, 'Software store build options', 'build')
  parser.add_option_group(buildgroup)
  
  publishgroup = OptionGroupId(parser, 'Software store publish options', 'publish')
  #publishgroup.add_option('--no-publish',
  #                  default=True,
  #                  action='store_false',
  #                  dest='publish',
  #                  help="do not publish the final output store to the web root")
  parser.add_option_group(publishgroup)

  args = sys.argv[1:]

  try:
    preargs = __filter_cmd_args(args,
                                ['--no-plugins'],
                                ['-c', '--config', '-l', '-e', '--conf-path',
                                 '--lib-path', '--share-path'])
  except ValueError:
    parser.print_help()
    sys.exit(1)
  
  opts,_ = parser.parse_args(args=preargs)

  mainconfig, distroconfig = __get_config(opts.mainconfigpath, opts.userconfig, opts.logthresh)

  #print opts

  import_dirs = mainconfig.xpath('//librarypaths/path/text()', [])
  if opts.libpath: import_dirs.insert(0, opts.libpath)
  
  for dir in sys.path:
    if dir not in import_dirs: import_dirs.append(dir)
  
  sys.path = import_dirs
  
  import_dirs = [ join(i, 'dimsbuild') for i in import_dirs ]
  
  # import dimsbuild from some path in import_dirs
  fp, path, desc = imp.find_module('main', import_dirs)
  build = imp.load_module('main', fp, path, desc)
  fp.close()
  
  # initialize our software builder with opts, the result of parsing preargs
  # we can't apply all options now, because plugins may modify the behavior
  # of the parser
  sbuilder = build.Build(opts, parser, mainconfig, distroconfig)
  
  # calculate the events available to --clean and --skip, and format nicely
  events = sbuilder.get_mdlr_events()
  parser.set_description("Valid events for EVENT, below, are: %s." % \
    listfmt.format(events, pre="'", post="'", last="and ", sep=", "))
  
  # now apply the real option set to the software builder, and run the main function
  options, args = parser.parse_args()
  sbuilder.apply_options(options)
  sbuilder.main()
  sys.exit()


def append_events_callback(option, opt, value, parser):
  events = []
  while parser.rargs:
    arg = parser.rargs[0]
    if ((arg[:2] == '--' and len(arg) > 2) or
        (arg[:1] == '-'  and len(arg) > 1 and arg[1] != '-')):
      break
    else:
      events.append(arg)
      del parser.rargs[0]
  if not hasattr(parser.values, option.dest):
    setattr(parser.values, option.dest, events)
  else:
    values = getattr(parser.values, option.dest)
    for event in events:
      if event not in values: values.append(event)


def __get_config(mainconfigpath, userconfig=None, loglevel=1):
  """Gets and reads in the dimsbuild configuration file.  Computes the location
  of the distribution-specific configuration, either by reading it from dimsbuild.conf
  or by using the user-specified config file."""
  
  # mainconfigpath now set via option parser and passed in as a function parameter
  # mainconfigpath = "/etc/dimsbuild/"
  
  mainconfig = configlib.read(join(mainconfigpath, 'dimsbuild.conf'))
  
  # neat trick - if userconfig is an absolute path, join() ignores defaultconfig
  if userconfig is not None:
    distroconfigpath = join(mainconfigpath, userconfig)
  else:
    distroconfigpath = join(mainconfigpath, mainconfig.get('//default/text()'))
  if exists(distroconfigpath):
    if isdir(distroconfigpath):
      distroconfigpath = join(distroconfigpath, 'distro.conf')
  else:
    raise OSError, "The config file '%s' doesn't exist" % distroconfigpath
  
  if loglevel >= 3: print "Reading config file '%s'" % distroconfigpath
  distroconfig = configlib.read(distroconfigpath)
  
  return mainconfig, distroconfig
  

def __filter_cmd_args(args, noargopts, argopts):
  """Filter args by removing items that are not in noargopts and argopts.
  noargopts is a list of arguments that take no arguments; argopts are
  arguments that do take arguments

  Looks awfully similar to a function that does the same thing in yum"""

  ret = []
  args = list(args) # copy args, this function is destructive

  while len(args) > 0:
    a = args.pop(0)
    if '=' in a:         # 'arg=value' style
      opt,_ = a.split('=', 1)
      if opt in argopts:
        ret.append(a)
    elif a in noargopts: # 'arg' style
      ret.append(a)
    elif a in argopts:   # 'arg value' style
      if len(args) < 1:
        raise ValueError
      next = args.pop(0)
      if next.startswith('-'):
        raise ValueError
      ret.extend([a,next])
    else:                # 'argvalue' style
      for opt in argopts:
        if len(opt) == 2 and a.startswith(opt):
          ret.append(a)
  return ret


if __name__ == "__main__": main()
