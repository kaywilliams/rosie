#!/usr/bin/python

""" 
dimsbuild

DimsBuild wrapper
"""

import imp
import os
import sys

from optparse import OptionParser, OptionGroup, SUPPRESS_HELP
from StringIO import StringIO

from dims import configlib
from dims import pps

from dims.CleanHelpFormatter import CleanHelpFormatter

P = pps.Path

def main():
  parser = OptionParser("usage: %prog [OPTIONS]", formatter=CleanHelpFormatter())
  
  parser.add_option('--clear-cache',
    dest='clear_cache',
    action='store_true',
    default=False,
    help="clear cache of downloaded files before executing")
  
  config_group = OptionGroup(parser, "config options")
  config_group.add_option('-c', '--distro-conf', metavar='PATH',
    default='distro.conf',
    dest='distropath',
    help="specify path to distro.conf file")
  config_group.add_option('--dimsbuild-conf', metavar='PATH',
    default='/etc/dimsbuild.conf',
    dest='mainconfigpath',
    help="specify path dimsbuild.conf")
  config_group.add_option('--no-validate',
    dest='no_validate',
    action='store_true',
    default=False,
    help="do not validate config files")
  config_group.add_option('--validate-only',
    dest='validate_only',
    default=False,
    action='store_true',
    help="validate config files and exit")
  parser.add_option_group(config_group)
  
  log_group = OptionGroup(parser, "logging options")
  log_group.add_option('-l', '--log-level', metavar='N',
    dest='logthresh',
    type='int',
    default=3,
    help="specify the level of verbosity of the output log")
  log_group.add_option('--log-file', metavar='PATH',
    dest='logfile',
    default='/var/log/dimsbuild.log',
    help="specify a file in which to log output")
  parser.add_option_group(log_group)
  
  module_group = OptionGroup(parser, "module and library options")
  module_group.add_option('--lib-path', metavar='PATH',
    dest='libpath',
    help="specify directory containing dimsbuild library files")
  module_group.add_option('--share-path', metavar='PATH',
    dest='sharepath',
    help="specify directory containing dimsbuild shared files")
  module_group.add_option('--enable-module', metavar='MODULE',
    action='append',
    dest='enabled_modules',
    default=[],
    help="load the specified module (included for config file parity)")
  module_group.add_option('--disable-module', metavar='MODULE',
    action='append',
    dest='disabled_modules',
    default=[],
    help="do not load the specified module")
  parser.add_option_group(module_group)
  
  event_group = OptionGroup(parser, "event control options")
  event_group.add_option('--force', metavar='EVENT',
    action='append',
    dest='force_events',
    default=[],
    help="force one or more events to execute")
  event_group.add_option('--skip', metavar='EVENT',
    action='append',
    dest='skip_events',
    default=[],
    help="skip processing one or more events")
  event_group.add_option('--list-events',
    action='store_true',
    default=False,
    dest='list_events',
    help="print out a list of all events and exit")
  parser.add_option_group(event_group)
  
  args = sys.argv[1:]
  
  try:
    preargs = __filter_cmd_args(args,
      noargopts = ['--no-plugins', '--no-validate', '--validate-only'],
      argopts   = ['-c', '--distro-conf', '--dimsbuild-conf',
                   '-l', '--log-level', '-e', '--err-level',
                   '--enable-module', '--disable-module',
                   '--lib-path', '--share-path'])
                                 
  except ValueError:
    parser.print_help()
    sys.exit(1)
  
  opts,_ = parser.parse_args(args=preargs)
  
  try:
    mainconfig, distroconfig = __get_conf(P(opts.mainconfigpath),
                                          P(opts.distropath),
                                          opts.logthresh)
  except OSError, e:
    if '-h' in args or '--help' in args:
      parser.print_help()
      sys.exit()
    else:
      print e
      sys.exit(1)
  
  # set up import_dirs
  import_dirs = mainconfig.xpath('/dimsbuild/librarypaths/path/text()', [])
  if opts.libpath: 
    import_dirs.insert(0, opts.libpath)
  import_dirs.insert(0, '.') # allow current directory imports to work
  for dir in sys.path:
    if dir not in import_dirs: import_dirs.append(dir)
  sys.path = import_dirs
  import_dirs = [ P(i)/'dimsbuild' for i in import_dirs ]
  
  # import dimsbuild from some path in import_dirs
  try:
    fp, path, desc = imp.find_module('main', import_dirs)
    build = imp.load_module('main', fp, path, desc)
    fp.close()
  except ImportError, e:
    print "Unable to load core dimsbuild files"
    raise #!
    sys.exit(1)
  
  # initialize our software builder with opts, the result of parsing preargs.
  # we can't apply all options now because modules may modify the behavior
  # of the parser
  sbuilder = build.Build(opts, parser, mainconfig, distroconfig)
  
  # now apply the real option set to the software builder and make it go!
  options, args = parser.parse_args()
  sbuilder.apply_options(options)
  sbuilder.main()
  sys.exit()

def __get_conf(maincfgpath, distrocfgpath, loglevel=1):
  "Computes the location and reads main and distro configuration files"
  
  if maincfgpath.exists():
    if loglevel >= 4: print "Reading reading main config file '%s'" % maincfgpath
    mainconfig = __read_conf(maincfgpath)
  else:
    if loglevel >= 4: print "No main config file found at '%s'. Using default settings" % maincfgpath
    mainconfig = __read_conf(StringIO('<dimsbuild></dimsbuild>'))
  
  distrocfgpath = distrocfgpath.expand().abspath()
  if not distrocfgpath.exists():
    raise OSError("No config file found at '%s'" % distrocfgpath)
  
  if loglevel >= 3: print "Reading distro config file '%s'" % distrocfgpath
  distroconfig = __read_conf(distrocfgpath)
  
  return mainconfig, distroconfig

def __read_conf(file):
  try:
    return configlib.read(file)
  except configlib.XmlSyntaxError, e:
    print "Error reading config file '%s'" % file
    print e, sys.exit(1)

def __filter_cmd_args(args, noargopts, argopts):
  """ 
  Filter args by removing items that are not in noargopts and argopts.
  noargopts is a list of arguments that take no arguments; argopts are
  arguments that do take arguments
  
  Looks awfully similar to a function that does the same thing in YUM
  """

  ret = []
  args = list(args) # copy args, this function is destructive

  while len(args) > 0:
    a = args.pop(0)
    if '=' in a:         # 'arg=value' style
      opt,_ = a.split('=', 1)
      if opt in argopts:
        ret.append(a)
    elif a in noargopts: # 'arg' style
      ret.append(a)
    elif a in argopts:   # 'arg value' style
      if len(args) < 1:
        raise ValueError
      next = args.pop(0)
      if next.startswith('-'):
        raise ValueError
      ret.extend([a,next])
    else:                # 'argvalue' style
      for opt in argopts:
        if len(opt) == 2 and a.startswith(opt):
          ret.append(a)
  return ret


if __name__ == '__main__': main()
