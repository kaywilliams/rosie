#
# Copyright (c) 2012
# CentOS Solutions, Inc. All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>
#
from ConfigParser import ConfigParser

import re
import lxml

from centosstudio.util import mkrpm
from centosstudio.util import pps

from centosstudio.errors    import CentOSStudioEventError
from centosstudio.event     import Event
from centosstudio.cslogging import L1

from centosstudio.util.rxml import datfile 

__all__ = ['RpmBuildMixin', 'Trigger', 'TriggerContainer']

class RpmBuildMixin:
  def __init__(self, *args, **kwargs):
    self.rpm = RpmBuildObject(self, *args,**kwargs)

  def setup(self, **kwargs):
    self.datfile = datfile.parse(basefile=self._config.file)
    self.rpm.setup_build(**kwargs)

  def run(self):
    R = self.rpm

    for path in [ R.build_folder, R.rpm_path, R.srpm_path ]:
      path.rm(recursive=True, force=True)

    if R.force_release: # use release if provided
      R.release = R.force_release
    else: # else use autogenerated one
      R.check_release() 

    R.build_folder.mkdirs()
    self.generate()
    R.write_spec()
    R.write_manifest()

    self.log(1, L1("building %s-%s-%s.%s.rpm" % \
                   (R.name, R.version, R.release, R.arch)))

    try:
      mkrpm.build(R.build_folder, self.mddir, createrepo=False,
                  bdist_base=R.bdist_base, rpm_base=R.rpm_base,
                  dist_dir=R.dist_dir, keep_source=True,
                  quiet=(int(self.logger.threshold) < 5))
    except mkrpm.rpmbuild.RpmBuilderException, e:
      raise RpmBuildFailedException(message=str(e))

    if 'gpg-signing-keys' in self.cvars:
      self.log(4, L1("signing %s-%s-%s.%s.rpm" % \
                     (R.name, R.version, R.release, R.arch)))
      R.sign()

    R.save_release()
    self.DATA['output'].append(R.rpm_path)
    self.DATA['output'].append(R.srpm_path)
    self.DATA['output'].append(self.rpm.build_folder)

  def apply(self):
    self.rpm._apply

  def verify_rpm_exists(self):
    "rpm exists"
    self.verifier.failUnlessExists(self.rpm.rpm_path)

  def verify_srpm_exists(self):
    "srpm exists"
    self.verifier.failUnlessExists(self.rpm.srpm_path)

  #----------- OPTIONAL METHODS --------#
  def generate(self):
    pass

  # determine what files are ghost
  def get_ghost_files(self): return None

  # rpm scripts
  def get_build(self):        return None
  def get_clean(self):        return None
  def get_install(self):      return None
  def get_post(self):         return None
  def get_postun(self):       return None
  def get_pre(self):          return None
  def get_prep(self):         return None
  def get_preun(self):        return None
  def get_verifyscript(self): return None

  # trigger scripts
  def get_triggers(self):     return None


class RpmBuildObject:
  def __init__(self, ptr, name, desc, summary, license=None,
               provides=None, obsoletes=None, requires=None,
               packagereq_type='mandatory', packagereq_default=None,
               packagereq_requires=None):
    self.ptr = ptr
    self.ptr.conditionally_requires.add('gpg-signing-keys')

    self.desc    = desc
    self.name    = name
    self.summary = summary
    self.license = license

    self.obsoletes = obsoletes or []
    self.requires  = requires  or []
    self.provides  = provides  or []

    if not self.ptr.config.getbool('@use-default-obsoletes', 'True'):
      self.obsoletes = []

    self.packagereq_type     = packagereq_type
    self.packagereq_default  = packagereq_default
    self.packagereq_requires = packagereq_requires

    # RPM build variables
    self.build_folder  = self.ptr.mddir / 'build'
    self.bdist_base    = self.build_folder / 'rpm-base'
    self.rpm_base      = self.build_folder / 'rpm'
    self.dist_dir      = self.build_folder / 'dist'
    self.source_folder = self.build_folder / 'source'

  #------------- PROPERTIES --------------#
  @property
  def rpm_path(self):
    return self.ptr.mddir/'RPMS/%s-%s-%s.%s.rpm' % \
             (self.name, self.version, self.release, self.arch)

  @property
  def srpm_path(self):
    return self.ptr.mddir/'SRPMS/%s-%s-%s.src.rpm' % \
           (self.name, self.version, self.release)

  @property
  def data_files(self):
    data_files = {}
    for item in self.source_folder.findpaths(type=pps.constants.TYPE_DIR,
                                             mindepth=1):
      files = item.findpaths(type=pps.constants.TYPE_NOT_DIR,
                             mindepth=1, maxdepth=1)
      if files:
        data_files.setdefault('/' / item.relpathfrom(self.source_folder), []).extend(files)
    return data_files

  #--------- RPM BUILD HELPER METHODS ---------#
  def setup_build(self, release=None, **kwargs):
    self.force_release = release

    self.release = self.ptr.datfile.get('/*/rpms/%s/release/text()' %
                                   (self.ptr.id), '0')

    self.obsoletes.extend(self.ptr.config.xpath('%s/obsoletes/text()' % 
                          self.ptr.rpmxpath, []))
    self.obsoletes.extend(kwargs.get('obsoletes', []))

    self.provides.extend([ x for x in self.obsoletes ])
    self.requires.extend(self.ptr.config.xpath('%s/provides/text()' %
                          self.ptr.rpmxpath, []))
    self.provides.extend(kwargs.get('provides', []))

    self.requires.extend(self.ptr.config.xpath('%s/requires/text()' %
                          self.ptr.rpmxpath, []))
    self.requires.extend(kwargs.get('requires', []))

    self.ptr.diff.setup(self.ptr.DATA)

    if 'gpg-signing-keys' in self.ptr.cvars:
      self.gpgsign = self.ptr.cvars['gpg-signing-keys'] # convenience variable
      self.ptr.DATA['input'].extend([self.gpgsign['pubkey'], 
                                     self.gpgsign['seckey']])
      self.ptr.DATA['variables'].append('cvars[\'gpg-signing-keys\'][\'passphrase\']')

    self.arch     = kwargs.get('arch',     'noarch')
    self.author   = kwargs.get('author',   'centosstudio')
    self.version  = kwargs.get('version',  self.ptr.version)

    self.ptr.DATA['variables'].extend(['rpm.name', 'rpm.arch', 'rpm.author', 
                                       'rpm.version'])

  def save_release(self):
    root = datfile.parse(basefile=self.ptr._config.file)
    uElement = datfile.uElement

    rpms     = uElement('rpms', parent=root)
    parent   = uElement(self.ptr.id, parent=rpms)
    release  = uElement('release', parent=parent, text=self.release)

    root.write()

  def check_release(self):
    if ( self.release == '0' or
         not self.ptr.mdfile.exists() or
         self.ptr.diff.input.difference() or
         self.ptr.diff.variables.difference() or
         self.ptr.diff.config.difference() ):
      self.release = str(int(self.release)+1)

  def write_spec(self):
    setupcfg = self.build_folder/'setup.cfg'

    spec = ConfigParser()

    # metadata section
    M = 'metadata'
    spec.add_section(M)

    spec.set(M, 'name',             self.name)
    spec.set(M, 'long_description', self.desc)
    spec.set(M, 'description',      self.summary)
    spec.set(M, 'author',           self.author)
    spec.set(M, 'version',          self.version)

    if self.license: spec.set(M, 'license', self.license)

    # bdist_rpm section
    B = 'bdist_rpm'
    spec.add_section(B)

    spec.set(B, 'force_arch',        self.arch)
    spec.set(B, 'distribution_name', self.name)
    spec.set(B, 'release',           self.release)

    if self.provides:  spec.set(B, 'provides',  ' '.join(self.provides))
    if self.requires:  spec.set(B, 'requires',  ' '.join(self.requires))
    if self.obsoletes: spec.set(B, 'obsoletes', ' '.join(self.obsoletes))

    # get the various script types
    build   = self.ptr.get_build()
    clean   = self.ptr.get_clean()
    install = self.ptr.get_install()
    post    = self.ptr.get_post()
    postun  = self.ptr.get_postun()
    pre     = self.ptr.get_pre()
    prep    = self.ptr.get_prep()
    preun   = self.ptr.get_preun()
    verify  = self.ptr.get_verifyscript()

    triggers = self.ptr.get_triggers()

    ghost = self.ptr.get_ghost_files()

    # add to bdist_rpm
    if build:   spec.set(B, 'build_script',   build)
    if clean:   spec.set(B, 'clean_script',   clean)
    if install: spec.set(B, 'install_script', install)
    if post:    spec.set(B, 'post_install',   post)
    if postun:  spec.set(B, 'post_uninstall', postun)
    if pre:     spec.set(B, 'pre_install',    pre)
    if prep:    spec.set(B, 'prep_script',    prep)
    if preun:   spec.set(B, 'pre_uninstall',  preun)
    if verify:  spec.set(B, 'verify_script',  verify)

    if triggers:
      trigcfg = self.build_folder / 'triggers.cfg'
      triggers.write_config(trigcfg)
      spec.set(B, 'trigger_configs', trigcfg)

    if ghost: spec.set(B, 'ghost_files', '\n\t'.join(ghost))

    # distribution related data
    D = 'distribution'
    spec.add_section(D)

    self.add_data_files(spec, D)
    #self.add_config_files(spec, B) #config-rpm manages independently
    self.add_doc_files(spec, B)

    f = open(setupcfg, 'w')
    spec.write(f)
    f.close()

  def write_manifest(self):
    manifest = ['setup.py', 'setup.cfg']
    manifest.extend( [ x.relpathfrom(self.build_folder) for x in
                       self.source_folder.findpaths(
                         type=pps.constants.TYPE_NOT_DIR) ])
    (self.build_folder/'MANIFEST').write_lines(manifest)

  def add_data_files(self, spec, section):
    data = []
    for dir, files in self.data_files.items():
      data.append('\t%s : %s' % (dir, ', '.join(files)))
    if data: spec.set(section, 'data_files', '\n'.join(data))

  def add_config_files(self, spec, section):
    cfg = []
    for dir,files in self.data_files.items():
      if dir.startswith('/etc'): # config files
        cfg.extend([ dir/x.basename for x in files ])
    if cfg: spec.set(section, 'config_files', '\n\t'.join(cfg))

  def add_doc_files(self, spec, section):
    doc = []
    if (self.source_folder / 'COPYING').exists():
      doc.append('COPYING')
    for dir,files in self.data_files.items():
      if dir.startswith('/usr/share/doc'):
        doc.extend([ dir/x.basename for x in files ])
    if doc: spec.set(section, 'doc_files', '\n\t'.join(doc))

  def sign(self):
    mkrpm.signRpms([self.rpm_path], public=self.gpgsign['pubkey'], 
                   secret=self.gpgsign['seckey'], 
                   passphrase=self.gpgsign['passphrase'], 
                   working_dir=self.ptr.mddir)

  def _apply(self):
    rpmbuild_data = {}

    rpmbuild_data['packagereq-default']  = self.packagereq_default
    rpmbuild_data['packagereq-requires'] = self.packagereq_requires
    rpmbuild_data['packagereq-type']     = self.packagereq_type

    rpmbuild_data['rpm-name']      = self.name
    rpmbuild_data['rpm-version']   = self.version
    rpmbuild_data['rpm-release']   = self.release
    rpmbuild_data['rpm-obsoletes'] = self.obsoletes
    rpmbuild_data['rpm-provides']  = self.provides
    rpmbuild_data['rpm-requires']  = self.requires

    rpmbuild_data['rpm-path']  = self.rpm_path
    rpmbuild_data['srpm-path'] = self.srpm_path

    self.ptr.cvars['rpmbuild-data'][self.ptr.id] = rpmbuild_data

class TriggerContainer(list):
  def __init__(self, iterable=None):
    iterable = iterable or []
    self.check(iterable)
    list.__init__(self, iterable)

  def write_config(self, file):
    lines = []
    for trigger in self:
      lines.append(str(trigger))
      lines.append('')
    file.write_lines(lines)

  def extend(self, item):
    self.check(item)
    list.extend(self, item)

  def append(self, item):
    self.check(item)
    list.append(self, item)

  def insert(self, index, item):
    self.check(item)
    list.insert(self, index, item)

  def check(self, item):
    if not hasattr(item, '__iter__'):
      item = [item]
    if isinstance(item, Trigger):
      return
    for x in item:
      if not isinstance(x, Trigger):
        raise TypeError("Trying to add non-Trigger object '%s' to TriggerContainer" % x)


class Trigger(dict):
  def __init__(self, id, **kwargs):
    self.id = id
    dict.__init__(self, **kwargs)

  def __str__(self):
    lines = ['[%s]' % self.id]
    if 'triggerid' not in self:
      lines.append('triggerid = %s' % self.id)
    for key, value in self.iteritems():
      if hasattr(value, '__iter__'):
        val = '\n\t'.join(value)
        lines.append('%s = %s' % (key, val.strip('\n')))
      else:
        lines.append('%s = %s' % (key, value))
    return '\n'.join(lines)


class RpmBuildFailedException(CentOSStudioEventError):
  message = "RPM build failed.  See build output below for details:\n%(message)s"

