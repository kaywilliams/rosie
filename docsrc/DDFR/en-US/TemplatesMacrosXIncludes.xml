<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="templates-macros-and-xincludes">

  <title>
  Templates, Macros and XIncludes
  </title>

  <para>
  To assist with definition creation and reuse, Deploy supports
  Templates, Macros and XIncludes.
  </para>
  
  <para>
  Templates are complete definitions, or segments of definitions, that can be
  used as a starting point for creating new definitions.
  </para>

  <para>
  Macros and XIncludes assist with content substitution.  These two methods
  overlap in some areas, and provide unique functionality in others.
  </para>
  
  <para>
  Used together, these three features offer a great deal of convenience and
  flexibility for creating definitions. They will be shown in many examples in
  the remainder of this document, as well as in other Deploy documentation
  and example files.
  </para>

  <section id="templates">
  <title>Templates</title>

  <xi:include href="common.xml" 
              xpointer="xpointer(//div[@id='templates-description']/*)"
              xmlns:xi="http://www.w3.org/2001/XInclude"/>

  </section>

  <section id="macros">
    <title>
    Macros 
    </title>
  
    <para>
    Macros provide a compact syntax for substituting
    <emphasis>content</emphasis> for <emphasis>placeholders</emphasis> within a
    definition. Macro definitions specify a macro id and associated replacement
    content. Content can include text, element, or mixed text and elements.
    Macro placeholders specify the location within the definition where the
    text is to be substituted.
    </para>
    
    <para>
    The syntax for macro placeholders is a percent sign preceding a
    macro id enclosed in braces: <emphasis>%{ID}</emphasis>. Placeholders can
    be used anywhere within the definition.
    </para>

    <para>
    Deploy supports four types of macros: <emphasis>command-line
    macros</emphasis>, <emphasis>in-document macros</emphasis>,
    <emphasis>global run-time macros</emphasis> and <emphasis>per-module
    run-time macros</emphasis>. 
    </para>

    <section id='command-line-macros'>

    <title>
    Command-Line Macros
    </title>

    <para>
    Command-line macros are specified using one or more macro options on the
    deploy command line. Macro options use the following syntax:
    <emphasis>--macro id:value</emphasis>.  Macros specified on the command
    line are the first to be resolved during Deploy processing, and their
    values override values provided by any other macro element or run-time
    macro. The example below shows a common usage scenario.
    </para>

    <para>
    <emphasis role='bold'>Example -</emphasis> In this example the macro
    placeholders <varname>%{os}</varname>, <varname>%{version}</varname> and
    <varname>%{arch}</varname> will be replaced with the values "centos", "6"
    and "i386", respectively, when Deploy is executed using the following
    command line:
    </para>

    <programlisting>
deploy --macro "os:centos" --macro "version:6" --macro "arch:i386" path/to/definition </programlisting>

    <para>
    This allows a single definition to be used across multiple os, version and
    arch operating system combinations. The definition is shown below:
    </para>

    <informalexample>
    <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definition schema-version="1.0" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;

&lt;main&gt;
&lt;name&gt;example&lt;name&gt;
&lt;os&gt;%{os}&lt;os&gt;
&lt;version&gt;%{version}&lt;version&gt;
&lt;arch&gt;%{arch}&lt;arch&gt;
&lt;id>example-%{os}-%{version}-%{arch}&lt;/id>
&lt;/main&gt;
...

&lt;/definition&gt;</programlisting>
    </informalexample>
    </section>

    <section id='in-document-macros'>
    <title>In-Document Macros</title>
    <para>
    In-Document Macros are specified using
    macro elements within the definition. Macro elements take a single
    attribute, "id", which identifies the name of the macro. The text of the
    macro element identifies content to substitute in place of the macro. For
    example:
    </para>
    
    <informalexample>
    <programlisting>
&lt;macro id="version"&gt;6&lt;/macro&gt;
    </programlisting>
    </informalexample>
    
    <para>
    In-document macros can be defined anywhere within the document.
    They are resolved following command-line macros, and they override
    run-time macros, described in the next section, with the same id.
    </para>

    <para>
    Multiple macro elements with the same id may exist within the definition.
    In this case, the value of the first element is used, and all
    remaining elements are silently ignored.
    </para>

    <para>
    <emphasis role='bold'>Example 1 - Global Macros.</emphasis> This example is
    similar to that in the previous section, with the addition of global
    in-document macros for <emphasis>name</emphasis>, <emphasis>os</emphasis>,
    <emphasis>version</emphasis>, <emphasis>arch</emphasis>, and
    <emphasis>id</emphasis>. When Deploy is executed with the command line from
    Example 1, the results will be the same as in that example (since
    command-line macros are resolved first).  However, when Deploy is executed
    with no macros specified on the command line, the values for os, version
    and macro will be "centos", "5" and "x86_64" respectively. In addition,
    because "name" and "id" are defined as macros, they will be available for
    use in other locations within the definition.
    </para>

    <para>
    In fact, because the configuration shown below is so flexible over time in
    facilitating migration across operating systems, versions and architecture,
    we use it in all of our examples, and we highly recommend it as a starting
    point for every definition.
    </para>

    <informalexample>
    <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definition schema-version="1.0" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;

&lt;macro id="name"&gt;example&lt;macro&gt;
&lt;macro id="os"&gt;centos&lt;macro&gt;
&lt;macro id="version"&gt;5&lt;macro&gt;
&lt;macro id="arch"&gt;x86_64&lt;macro&gt;
&lt;macro id="id"&gt;%{name}-%{os}-%{version}-%{arch}&lt;macro&gt;

&lt;main>
&lt;name>%{name}&lt;name>
&lt;os>%{os}&lt;os>
&lt;version>%{version}&lt;version>
&lt;arch>%{arch}&lt;arch>
&lt;id>%{id}&lt;id>
&lt;/main>
...

&lt;/definition&gt;</programlisting>
    </informalexample>

    <para>
    <emphasis role='bold'>Example 2 - Nested Macros</emphasis>. Macros can 
    be nested to support conditional content inclusion. Nested macros are a
    powerful and practical tool. They allow a single file to be used across
    multiple operating systems, versions and architectures, even when
    requirements vary. This is especially useful during system migrations.
    </para>

    <para>
    The example below shows a <emphasis>packages</emphasis> element containing
    two groups (core and base), and a nested <emphasis>macro</emphasis>
    placeholder. The nested placeholder selects additional content based on the
    value provided for the <emphasis>version</emphasis> macro. In the default
    case (version=5), the list of groups for the repository will be "core, base
    and smb-server".  If the version macro is set to "6", however, either
    manually or using a command-line macro, the list of groups will be "core,
    base and cifs-file-server".
    </para>

    <informalexample>
    <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definition xmlns:xi="http://www.w3.org/2001/XInclude"&gt;

&lt;macro id="version"&gt;5&lt;macro&gt;
&lt;macro id="arch"&gt;i386&lt;macro&gt;

&lt;packages&gt;
&lt;group&gt;core&lt;group&gt;
&lt;group&gt;base&lt;group&gt;
%{packages-%{version}}
&lt;/packages&gt;

&lt;macro id="packages-5">
&lt;group>smb-server&lt;/group>
&lt;/macro>

&lt;macro id="packages-6">
&lt;group>cifs-file-server&lt;/group>
&lt;/macro>
...
&lt;/definition&gt;</programlisting>
    </informalexample>
    </section>

    <section>
    <title>Global Run-Time Macros</title>
    <para>
    Global run-time macros are defined by Deploy during the build process and
    applied across all Deploy modules. Deploy provides three global run-time
    macros: <emphasis>%{definition-dir}</emphasis>, <emphasis>
    %{templates-dir}</emphasis> and %{data-dir}.
    </para>

    <variablelist>
    <varlistentry id="definition-dir">
    <term>
    %{definition-dir}
    </term>
    <listitem>
    <para>
    The folder location of the definition file. Useful for specifying files and
    folders relative to the definition file.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
    %{templates-dir}
    </term>
    <listitem>
    <para>
    The folder location of Deploy-provided templates,
    <filename>/usr/share/deploy/templates</filename> by default. Can be set
    using the <emphasis>templates-path</emphasis> element of the Deploy
    Configuration file. See <command>man deloy.conf</command> for additional
    information.  Useful for specifying files and folders relative to the
    templates folder.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
    %{data-dir}
    </term>
    <listitem>
    <para>
    The folder location of the <xref linkend='datfile'/>. Useful for scripts to
    store and retrieve runtime-generated, per-build-ID data such as machine
    hostnames and ssh keys.
    </para>

    <para>
    The <emphasis>%{data-dir}</emphasis> macro is not supported within XInclude
    attributes including <emphasis>href</emphasis> and
    <emphasis>xpointer</emphasis>.
    </para>
    </listitem>
    </varlistentry>
    </variablelist>

    <para>
    Global run-time macros are resolved following in-document macros.
    </para>
    </section>

    <section>
    <title>Per-Module Run-Time Macros</title>
    <para>
    Per-module run-time macros are macros that are
    defined by specific modules within the Deploy build process.
    Modules that provide run-time macros include
    <emphasis>config-rpms</emphasis>, <emphasis>srpmbuild</emphasis>,
    <emphasis>test-install</emphasis>, <emphasis>test-update</emphasis> and
    <emphasis>publish</emphasis>. See these modules for more information.
    </para>

    <para>
    Per-module run-time macros are the last to be resolved.
    </para>
    </section>

  </section>
  
  <section id="xincludes">
    <title>
    XIncludes
    </title>
  
    <para>
    XML Inclusions (XIncludes) are an industry standard sponsored by the World
    Wide Web Consortium (W3C). This section provides a brief overview and an
    example of using XIncludes in definitions. More information on
    XInclude is available from <ulink url="http://www.w3.org/TR/xinclude/"/>
    </para>
    
    <para>
    Similar to macros, XIncludes allow content reuse in definitions.
    There are two important differences between the two mechanisms,
    however:
    </para>

    <itemizedlist>

      <listitem>
      <para>
      XIncludes can be used to include content from external files. Macros
      cannot.
      </para>
      </listitem>

      <listitem>
      <para>
      Macros can be used within attribute text, e.g.  <varname>&lt;repo
      id="centos-%{version}-%{arch}"&gt;</varname>. XIncludes cannot.
      </para>
      </listitem>

    </itemizedlist>

    <formalpara  id="xinclude-namespace-declaration">
    <title>XInclude Namespace Declaration</title>

    <para>
    XIncludes require the use of an XML namespace declaration in the containing
    document. This is commonly accomplished by adding an xmlns attribute within
    the repo element as follows: 
    </para>
    </formalpara>
    
    <informalexample>
    <programlisting>
&lt;definition xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
    </programlisting>
    </informalexample> 
    
    <para>
    As a matter of practice, we recommend including this namespace declaration
    in every XML file you create for use with Deploy. This will allow the
    addition of XIncludes at any time, without causing potentially confusing
    errors in definition processing.
    </para>

    <para>
    XIncludes can be nested, e.g. <filename>repository1.definition</filename>
    can include content from <filename>document2.xml</filename>, which can
    further include content from <filename>document3.xml</filename>. Each
    document that contains an XInclude, e.g.
    <filename>repository1.definition</filename> and
    <filename>document2.xml</filename>, must also include the namespace
    definition. 
    </para>

    <formalpara>
    <title>XInclude Limitations</title>
    <para>
    Deploy supports a limited implementation of the XInclude specification. In particular:
    </para>
    </formalpara>
    
    <orderedlist>
    <listitem>
    <para>
    It does not support <emphasis>fallbacks</emphasis>.
    </para>
    </listitem>
    <listitem>
    <para>
    It supports only the <emphasis>xpointer()</emphasis> scheme.
    </para>
    </listitem>
    </orderedlist>

    <section>
    <title>Examples</title>
    <para>
    XInclude offers a number of features, more than we will cover in this
    document. The examples below do illustrate, however, several common
    scenarios for using XIncludes in definitions.
    </para>

    <formalpara id="xinclude-text-document-example"> 
      <title>
      Example 1 - Including an external <emphasis>text</emphasis> document.
      </title>
      <para>
      The example below uses XInclude to include content from a text
      file named <filename>file.txt</filename>. The
      name of the XInclude element is <varname>xi:include</varname>.
      Technically <emphasis>xi:</emphasis> is the prefix, as established in 
      <xref linkend="xinclude-namespace-declaration"/>, to the element named
      <emphasis>include</emphasis>. For simplicity throughout the remainder of
      this document, however, we will refer to it as the
      <varname>xi:include</varname> element. The <varname>href</varname>
      attribute identifies the path of the file for inclusion, in this case a
      file named file.txt in the same folder as the definition. The
      <varname>parse</varname> attribute indicates that the file to be included
      is in <emphasis>text</emphasis> format, rather than XML (the default).
      </para>
      </formalpara>

      <informalexample>
      <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definition xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
...
&lt;xi:include href="file.txt" parse="text" /&gt;
...
&lt;/definition&gt;</programlisting>
      </informalexample>

    <formalpara id="xinclude-xml-document-example"> 
      <title>
      Example 2 - Including an external <emphasis>XML</emphasis> document.
      </title>
      <para>
      In this example, an entire xml document, <filename>update.xml</filename>
      is included within the definition. This example is similar to Example 1
      above, except that the <emphasis>parse</emphasis> attribute is not 
      required since the included file is in the default XML format.
      </para>
      </formalpara>

      <informalexample>
      <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definition xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
...
&lt;xi:include href="repos.xml"/&gt;
...
&lt;/definition&gt;</programlisting>
      </informalexample>

    <formalpara id="xinclude-xml-segment-example">
      <title>
      Example 3 - Including segments of <emphasis>XML</emphasis> documents.
      </title>
      <para>
      This example shows two documents, <filename>repos.xml</filename> and
      <filename>example.definition</filename>. The
      <filename>repos.xml</filename> document contains definitions for several
      input repositories. Two of these will be included in the
      <filename>example.definition </filename> using
      <varname>xi:include</varname> elements. The <varname>xpointer</varname>
      attributes of the <varname>xi:include</varname> elements identify the
      segments for inclusion.
      </para>
      </formalpara>

      <note>
      <para>
      On a system with the Deploy RPM installed, the <filename>
      repos.xml</filename> document can be found in the examples folder at
      <filename>/usr/share/deploy/../../share/deploy/templates/</filename>.
      </para>
      </note>

      <para><emphasis role="strong">repos.xml</emphasis></para>
      <informalexample>
      <programlisting>
<xi:include href="../../../../../share/deploy/templates/common/repos.xml"
            parse="text"
            xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
      </informalexample>

      <para><emphasis role="strong">example.definition</emphasis></para>
      <informalexample>
      <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definition xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
...
&lt;repos&gt;
&lt;xi:include href='repos.xml' xpointer="xpointer(/*/repo[@id='base'])"/&gt;
&lt;xi:include href='repos.xml' xpointer="xpointer(/*/repo[@id='updates'])"/&gt;
&lt;/repos&gt;

&lt;/definition&gt;</programlisting>
      </informalexample>
    </section>
  </section>
</chapter>
